import matplotlib
matplotlib.use('TkAgg')  # 使用交互式后端（需安装 tkinter）
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, Button, RadioButtons
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
import matplotlib.gridspec as gridspec
from matplotlib.colors import LinearSegmentedColormap

# 设置中文显示
plt.rcParams["font.family"] = ["SimHei", "WenQuanYi Micro Hei", "Heiti TC"]
plt.rcParams["axes.unicode_minus"] = False  # 解决负号显示问题


class BlochSphereVisualizer:
    """布洛赫球可视化工具类，支持单量子比特和多量子比特叠加态展示"""

    def __init__(self):
        """初始化布洛赫球可视化工具"""
        self.fig = plt.figure(figsize=(14, 8))
        self.spec = gridspec.GridSpec(ncols=2, nrows=1, figure=self.fig, width_ratios=[3, 1])

        # 创建3D绘图区域
        self.ax = self.fig.add_subplot(self.spec[0, 0], projection='3d')
        self.ax.set_aspect("equal")

        # 创建控制面板区域
        self.control_ax = self.fig.add_subplot(self.spec[0, 1])
        self.control_ax.set_title("Quantum State Controls", fontsize=14)
        self.control_ax.axis('off')

        # 量子态参数
        self.theta = np.pi / 2  # 极角
        self.phi = np.pi / 4  # 方位角
        self.gamma = 0  # 相位角
        self.num_qubits = 1  # 量子比特数

        # 创建自定义颜色映射
        self.colors = [(0.2, 0.4, 0.8), (0.8, 0.2, 0.2)]  # 蓝到红
        self.cmap = LinearSegmentedColormap.from_list('qubit_map', self.colors, N=100)

        # 初始化图形
        self._init_plot()
        self._init_controls()

        # 更新图形
        self.update_plot()

    def _init_plot(self):
        """初始化布洛赫球图形"""
        # 清空当前图形
        self.ax.clear()

        # 设置标题
        self.ax.set_title("Quantum Superposition Visualization", fontsize=16)

        # 绘制球体
        u, v = np.mgrid[0:2 * np.pi:40j, 0:np.pi:20j]
        x = np.cos(u) * np.sin(v)
        y = np.sin(u) * np.sin(v)
        z = np.cos(v)
        self.ax.plot_wireframe(x, y, z, color='gray', alpha=0.15)

        # 绘制坐标轴
        self.ax.plot([-1.2, 1.2], [0, 0], [0, 0], 'k-', lw=1)
        self.ax.plot([0, 0], [-1.2, 1.2], [0, 0], 'k-', lw=1)
        self.ax.plot([0, 0], [0, 0], [-1.2, 1.2], 'k-', lw=1)

        # 添加坐标轴标签
        self.ax.text(1.3, 0, 0, r'$|0\rangle$', fontsize=12)
        self.ax.text(-1.3, 0, 0, r'$|1\rangle$', fontsize=12)
        self.ax.text(0, 1.3, 0, r'$|+\rangle$', fontsize=12)
        self.ax.text(0, -1.3, 0, r'$|-\rangle$', fontsize=12)
        self.ax.text(0, 0, 1.3, r'$|i\rangle$', fontsize=12)
        self.ax.text(0, 0, -1.3, r'$|-i\rangle$', fontsize=12)

        # 设置坐标轴范围
        self.ax.set_xlim([-1.2, 1.2])
        self.ax.set_ylim([-1.2, 1.2])
        self.ax.set_zlim([-1.2, 1.2])

        # 隐藏坐标轴刻度
        self.ax.set_xticks([])
        self.ax.set_yticks([])
        self.ax.set_zticks([])

        # 设置视角
        self.ax.view_init(elev=30, azim=45)

    def _init_controls(self):
        """初始化控制面板"""
        # 清除控制面板
        self.control_ax.clear()
        self.control_ax.set_title("Quantum State Controls", fontsize=14)
        self.control_ax.axis('off')

        # 创建滑块位置
        slider_height = 0.05
        slider_spacing = 0.07
        button_height = 0.07
        start_y = 0.85

        # 创建极角滑块
        theta_ax = self.fig.add_axes([0.75, start_y, 0.2, slider_height])
        self.theta_slider = Slider(
            ax=theta_ax,
            label=r'Polar angle θ',
            valmin=0,
            valmax=np.pi,
            valinit=self.theta,
            valfmt='%1.2f rad'
        )
        self.theta_slider.on_changed(self._update_theta)

        # 创建方位角滑块
        phi_ax = self.fig.add_axes([0.75, start_y - slider_spacing, 0.2, slider_height])
        self.phi_slider = Slider(
            ax=phi_ax,
            label=r'Azimuthal angle φ',
            valmin=0,
            valmax=2 * np.pi,
            valinit=self.phi,
            valfmt='%1.2f rad'
        )
        self.phi_slider.on_changed(self._update_phi)

        # 创建相位角滑块
        gamma_ax = self.fig.add_axes([0.75, start_y - 2 * slider_spacing, 0.2, slider_height])
        self.gamma_slider = Slider(
            ax=gamma_ax,
            label=r'Phase angle γ',
            valmin=0,
            valmax=2 * np.pi,
            valinit=self.gamma,
            valfmt='%1.2f rad'
        )
        self.gamma_slider.on_changed(self._update_gamma)

        # 创建量子比特数选择按钮
        qubits_ax = self.fig.add_axes([0.75, start_y - 3.5 * slider_spacing, 0.2, button_height])
        self.qubits_button = Button(qubits_ax, f'Number of qubits: {self.num_qubits}')
        self.qubits_button.on_clicked(self._toggle_qubits)

        # 创建状态显示区域
        self.state_text = self.control_ax.text(0.05, 0.3, "", transform=self.control_ax.transAxes,
                                               fontsize=12, bbox=dict(facecolor='white', alpha=0.5))

        # 创建基态概率分布图
        self.prob_ax = self.fig.add_axes([0.75, 0.05, 0.2, 0.2])
        self.prob_ax.set_title("Basis State Probabilities", fontsize=10)
        self.prob_bars = None

    def _update_theta(self, val):
        """更新极角"""
        self.theta = val
        self.update_plot()

    def _update_phi(self, val):
        """更新方位角"""
        self.phi = val
        self.update_plot()

    def _update_gamma(self, val):
        """更新相位角"""
        self.gamma = val
        self.update_plot()

    def _toggle_qubits(self, event):
        """切换量子比特数"""
        self.num_qubits = 2 if self.num_qubits == 1 else 1
        self.qubits_button.label.set_text(f'Number of qubits: {self.num_qubits}')
        self._init_plot()
        self.update_plot()

    def update_plot(self):
        """更新布洛赫球图形"""
        self._init_plot()

        if self.num_qubits == 1:
            # 单量子比特情况
            self._plot_single_qubit()
        else:
            # 双量子比特情况
            self._plot_two_qubits()

        # 更新状态文本
        self._update_state_text()

        # 更新概率分布图
        self._update_prob_distribution()

        # 刷新图形
        self.fig.canvas.draw_idle()

    def _plot_single_qubit(self):
        """绘制单量子比特叠加态"""
        # 计算叠加态向量坐标
        x_point = np.sin(self.theta) * np.cos(self.phi)
        y_point = np.sin(self.theta) * np.sin(self.phi)
        z_point = np.cos(self.theta)

        # 计算量子态系数
        alpha = np.cos(self.theta / 2)
        beta = np.exp(1j * self.gamma) * np.sin(self.theta / 2)

        # 绘制叠加态向量
        self.ax.quiver(0, 0, 0, x_point, y_point, z_point, color='red',
                       length=1.0, normalize=True, lw=2)

        # 绘制向量在各个平面上的投影
        self.ax.plot([0, x_point], [0, y_point], [0, 0], 'r--', alpha=0.5)
        self.ax.plot([0, x_point], [0, 0], [0, z_point], 'r--', alpha=0.5)
        self.ax.plot([0, 0], [0, y_point], [0, z_point], 'r--', alpha=0.5)

        # 绘制向量端点
        self.ax.scatter(x_point, y_point, z_point, color='red', s=50)

        # 添加状态标签
        self.ax.text(x_point * 1.1, y_point * 1.1, z_point * 1.1, r'$|\psi\rangle$', fontsize=12)

    def _plot_two_qubits(self):
        """绘制双量子比特叠加态"""
        # 将单量子比特参数映射到双量子比特系统
        # 这里使用简化模型，将参数分布到两个量子比特上
        theta1 = self.theta
        phi1 = self.phi
        theta2 = np.pi / 2 - self.theta / 2
        phi2 = self.phi + self.gamma

        # 计算两个量子比特的向量坐标
        x1 = np.sin(theta1) * np.cos(phi1)
        y1 = np.sin(theta1) * np.sin(phi1)
        z1 = np.cos(theta1)

        x2 = np.sin(theta2) * np.cos(phi2)
        y2 = np.sin(theta2) * np.sin(phi2)
        z2 = np.cos(theta2)

        # 计算双量子比特状态系数
        alpha00 = np.cos(theta1 / 2) * np.cos(theta2 / 2)
        alpha01 = np.cos(theta1 / 2) * np.sin(theta2 / 2) * np.exp(1j * phi2)
        alpha10 = np.sin(theta1 / 2) * np.exp(1j * phi1) * np.cos(theta2 / 2)
        alpha11 = np.sin(theta1 / 2) * np.exp(1j * phi1) * np.sin(theta2 / 2) * np.exp(1j * phi2)

        # 绘制第一个量子比特
        self.ax.quiver(0, 0, 0, x1, y1, z1, color='blue',
                       length=0.9, normalize=True, lw=2)
        self.ax.scatter(x1, y1, z1, color='blue', s=40)
        self.ax.text(x1 * 1.05, y1 * 1.05, z1 * 1.05, r'$Q_1$', fontsize=10, color='blue')

        # 绘制第二个量子比特
        self.ax.quiver(0, 0, 0, x2, y2, z2, color='green',
                       length=0.9, normalize=True, lw=2)
        self.ax.scatter(x2, y2, z2, color='green', s=40)
        self.ax.text(x2 * 1.05, y2 * 1.05, z2 * 1.05, r'$Q_2$', fontsize=10, color='green')

        # 绘制纠缠态连接线
        self.ax.plot([x1, x2], [y1, y2], [z1, z2], 'purple', linestyle='--', alpha=0.6)

    def _update_state_text(self):
        """更新状态文本显示"""
        if self.num_qubits == 1:
            # 计算量子态系数
            alpha = np.cos(self.theta / 2)
            beta = np.exp(1j * self.gamma) * np.sin(self.theta / 2)

            # 格式化量子态
            state_text = r"$|\psi\rangle = {0:.3f}|0\rangle + {1:.3f}e^{{i{2:.3f}}}|1\rangle$".format(
                alpha.real, np.abs(beta), self.gamma)

            # 计算概率
            prob0 = np.abs(alpha) ** 2
            prob1 = np.abs(beta) ** 2

            prob_text = "\Probability distribution:\n"
            prob_text += r"$P(|0\rangle) = {0:.3f}$".format(prob0)
            prob_text += "\n"
            prob_text += r"$P(|1\rangle) = {0:.3f}$".format(prob1)

            # 显示状态
            self.state_text.set_text(state_text + prob_text)
        else:
            # 双量子比特情况
            theta1 = self.theta
            phi1 = self.phi
            theta2 = np.pi / 2 - self.theta / 2
            phi2 = self.phi + self.gamma

            # 计算双量子比特状态系数
            alpha00 = np.cos(theta1 / 2) * np.cos(theta2 / 2)
            alpha01 = np.cos(theta1 / 2) * np.sin(theta2 / 2) * np.exp(1j * phi2)
            alpha10 = np.sin(theta1 / 2) * np.exp(1j * phi1) * np.cos(theta2 / 2)
            alpha11 = np.sin(theta1 / 2) * np.exp(1j * phi1) * np.sin(theta2 / 2) * np.exp(1j * phi2)

            # 格式化量子态
            state_text = r"$|\psi\rangle = {0:.3f}|00\rangle + {1:.3f}e^{{i{2:.3f}}}|01\rangle + {3:.3f}e^{{i{4:.3f}}}|10\rangle + {5:.3f}e^{{i{6:.3f}}}|11\rangle$".format(
                alpha00.real, np.abs(alpha01), phi2, np.abs(alpha10), phi1, np.abs(alpha11), phi1 + phi2)

            # 计算概率
            prob00 = np.abs(alpha00) ** 2
            prob01 = np.abs(alpha01) ** 2
            prob10 = np.abs(alpha10) ** 2
            prob11 = np.abs(alpha11) ** 2

            prob_text = "\nProbability distribution:\n"
            prob_text += r"$P(|00\rangle) = {0:.3f}$".format(prob00)
            prob_text += "\n"
            prob_text += r"$P(|01\rangle) = {0:.3f}$".format(prob01)
            prob_text += "\n"
            prob_text += r"$P(|10\rangle) = {0:.3f}$".format(prob10)
            prob_text += "\n"
            prob_text += r"$P(|11\rangle) = {0:.3f}$".format(prob11)

            # 显示状态
            self.state_text.set_text(state_text + prob_text)

    def _update_prob_distribution(self):
        """更新基态概率分布图"""
        self.prob_ax.clear()
        self.prob_ax.set_title("Basis State Probabilities", fontsize=10)

        if self.num_qubits == 1:
            # 单量子比特概率
            alpha = np.cos(self.theta / 2)
            beta = np.exp(1j * self.gamma) * np.sin(self.theta / 2)

            probs = [np.abs(alpha) ** 2, np.abs(beta) ** 2]
            states = [r'$|0\rangle$', r'$|1\rangle$']
            colors = ['blue', 'red']

            self.prob_bars = self.prob_ax.bar(states, probs, color=colors, alpha=0.7)
            self.prob_ax.set_ylim(0, 1.1)

            # 添加数值标签
            for i, rect in enumerate(self.prob_bars):
                height = rect.get_height()
                self.prob_ax.text(rect.get_x() + rect.get_width() / 2., height + 0.02,
                                  f'{probs[i]:.3f}', ha='center', va='bottom')
        else:
            # 双量子比特概率
            theta1 = self.theta
            phi1 = self.phi
            theta2 = np.pi / 2 - self.theta / 2
            phi2 = self.phi + self.gamma

            # 计算双量子比特状态系数
            alpha00 = np.cos(theta1 / 2) * np.cos(theta2 / 2)
            alpha01 = np.cos(theta1 / 2) * np.sin(theta2 / 2) * np.exp(1j * phi2)
            alpha10 = np.sin(theta1 / 2) * np.exp(1j * phi1) * np.cos(theta2 / 2)
            alpha11 = np.sin(theta1 / 2) * np.exp(1j * phi1) * np.sin(theta2 / 2) * np.exp(1j * phi2)

            probs = [np.abs(alpha00) ** 2, np.abs(alpha01) ** 2, np.abs(alpha10) ** 2, np.abs(alpha11) ** 2]
            states = [r'$|00\rangle$', r'$|01\rangle$', r'$|10\rangle$', r'$|11\rangle$']

            # 创建颜色渐变
            colors = [self.cmap(i / 3) for i in range(4)]

            self.prob_bars = self.prob_ax.bar(states, probs, color=colors, alpha=0.7)
            self.prob_ax.set_ylim(0, 1.1)

            # 添加数值标签
            for i, rect in enumerate(self.prob_bars):
                height = rect.get_height()
                self.prob_ax.text(rect.get_x() + rect.get_width() / 2., height + 0.02,
                                  f'{probs[i]:.3f}', ha='center', va='bottom')

    def show(self):
        """显示图形"""
        plt.tight_layout()
        plt.show()


# 创建并显示可视化工具
if __name__ == "__main__":
    visualizer = BlochSphereVisualizer()
    visualizer.show()
